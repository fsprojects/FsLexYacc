<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Overview
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Lex and Yacc for F#">
    <meta name="author" content="FsLexYacc contributors">

    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">

    <link type="text/css" rel="stylesheet" href="/FsLexYacc/content/style.css" />
    <script type="text/javascript" src="/FsLexYacc/content/tips.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="https://fsharp.org">fsharp.org</a></li>
          <li><a href="http://github.com/fsprojects/FsLexYacc">github page</a></li>
        </ul>
        <h3 class="muted"><a href="file://C:\GitHub\dsyme\FsLexYacc\docsrc/../docs/index.html">FsLexYacc</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          
<h1>Overview</h1>
<p>The <code>fslex.exe</code> tool is a lexer generator for byte and Unicode character input.</p>
<h2>Getting Started</h2>
<p>Add an <code>FsLexYacc</code> package reference to your project</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="o">&lt;</span><span class="i">PackageReference</span> <span class="i">Include</span><span class="o">=</span><span class="s">&quot;FsLexYacc&quot;</span> <span class="i">Version</span><span class="o">=</span><span class="s">&quot;9.0.2&quot;</span> <span class="o">/&gt;</span>
</code></pre></td>
</tr>
</table>
<p>You then add <code>FsLex</code> and <code>FsYacc</code> entries like this:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="o">&lt;</span><span class="i">FsYacc</span> <span class="i">Include</span><span class="o">=</span><span class="s">&quot;..\LexAndYaccMiniProject\Parser.fsy&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="i">OtherFlags</span><span class="o">&gt;</span><span class="o">--</span><span class="k">module</span> <span class="i">Parser</span><span class="o">&lt;/</span><span class="i">OtherFlags</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="i">FsYacc</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="i">FsLex</span> <span class="i">Include</span><span class="o">=</span><span class="s">&quot;..\LexAndYaccMiniProject\Lexer.fsl&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="i">OtherFlags</span><span class="o">&gt;</span><span class="o">--</span><span class="k">module</span> <span class="i">Lexer</span> <span class="o">--</span><span class="i">unicode</span><span class="o">&lt;/</span><span class="i">OtherFlags</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="i">FsLex</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<h2>Lexer syntax</h2>
<p>Define your lexer in the Lexer.fsl file.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">{ <span class="i">header</span> }
<span class="k">let</span> <span class="i">ident</span> <span class="o">=</span> <span class="i">regexp</span> <span class="o">..</span><span class="o">.</span>
<span class="i">rule</span> <span class="i">entrypoint</span> [<span class="i">arg1</span><span class="o">..</span><span class="o">.</span> <span class="i">argn</span>] <span class="o">=</span>
  <span class="i">parse</span> <span class="i">regexp</span> { <span class="i">action</span> }
      | <span class="o">..</span><span class="o">.</span>
      | <span class="i">regexp</span> { <span class="i">action</span> }
<span class="k">and</span> <span class="i">entrypoint</span> [<span class="i">arg1</span>
  <span class="i">parse</span> <span class="o">..</span><span class="o">.</span>
<span class="k">and</span> <span class="o">..</span><span class="o">.</span>
{ <span class="i">trailer</span> }
</code></pre></td>
</tr>
</table>
<p>Comments are delimited by (<em> and </em>) and line comments // are also supported, as in F#.</p>
<p>The rule and parse keywords are required.</p>
<p>The header and trailer sections are arbitrary F# code, which will write to the beginning and end of the output file (Lexer.fs).
Either or both can be omitted. Headers typically include values and functions used in the rule body actions.</p>
<p>Following the header and before the rules are named regular expressions for use in the rules.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">ident</span> <span class="o">=</span> <span class="i">regexp</span> 
</code></pre></td>
</tr>
</table>
<p>Following this declaration, the identifier ident can be used as shorthand for regexp.</p>
<h2>Entry points</h2>
<p>Entry points are valid F# identifiers. Similarly, the arguments</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">arg1</span><span class="o">..</span><span class="o">.</span> <span class="i">argn</span> 
</code></pre></td>
</tr>
</table>
<p>must be valid identifiers.
Each entry point becomes a function that takes n+1 arguments, the implicit last argument being of type LexBuffer<'a>.
Characters are read from the LexBuffer<'a> argument and matched against the regular expressions provided in the rule, until a prefix of the input matches one of the rules.
The Lexer then evaluates the action and returns it as the result of the function. Rule entry points can be entered recursively.</p>
<p>If several regular expressions match a prefix of the input the regular expression that matches the longest prefix of the input is selected.
In case of tie, the regular expression that occurs earlier in the rule is selected.</p>
<h2>Rule regular expressions</h2>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="o">&#39;</span> <span class="i">regular</span><span class="o">-</span><span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="i">char</span> | <span class="i">escape</span><span class="o">-</span><span class="i">sequence</span> <span class="o">&#39;</span>
</code></pre></td>
</tr>
</table>
<p>A character constant, with the same syntax as F# character constants. Match the denoted character.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">_
</code></pre></td>
</tr>
</table>
<p>(underscore) Match any character.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">eof</span>
</code></pre></td>
</tr>
</table>
<p>Match the end of the lexer input.</p>
<p>Note: Fslex will not correctly handle regular expressions that contain eof followed by something else.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;string&quot;</span>
</code></pre></td>
</tr>
</table>
<p>A string constant, with the same syntax as F# string constants. Match the corresponding sequence of characters.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"></pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"></code></pre></td>
</tr>
</table>
<p>Match any single character belonging to the given character set. Valid character sets are: single character constants ' c '; ranges of characters ' c1 ' - ' c2 ' (all characters between c1 and c2, inclusive); and the union of two or more character sets, denoted by concatenation.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">[ <span class="o">^</span> <span class="i">character</span><span class="o">-</span><span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="i">set</span> ]
</code></pre></td>
</tr>
</table>
<p>Match any single character not belonging to the given character set.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">regexp1</span> # <span class="i">regexp2</span>
</code></pre></td>
</tr>
</table>
<p>(difference of character sets) Regular expressions regexp1 and regexp2 must be character sets defined with […] (or a a single character expression or underscore _). Match the difference of the two specified character sets.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">regexp</span> <span class="o">*</span>
</code></pre></td>
</tr>
</table>
<p>(repetition) Match the concatenation of zero or more strings that match regexp.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">regexp</span> <span class="o">+</span>
</code></pre></td>
</tr>
</table>
<p>(strict repetition) Match the concatenation of one or more strings that match regexp.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">regexp</span> <span class="o">?</span>
</code></pre></td>
</tr>
</table>
<p>(option) Match the empty string, or a string matching regexp.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">regexp1</span> | <span class="i">regexp2</span>
</code></pre></td>
</tr>
</table>
<p>(alternative) Match any string that matches regexp1 or regexp2</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">regexp1</span> <span class="i">regexp2</span>
</code></pre></td>
</tr>
</table>
<p>(concatenation) Match the concatenation of two strings, the first matching regexp1, the second matching regexp2.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">( <span class="i">regexp</span> )
</code></pre></td>
</tr>
</table>
<p>Match the same strings as regexp.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">ident</span>
</code></pre></td>
</tr>
</table>
<p>Reference the regular expression bound to ident by an earlier let ident =  regexp definition.</p>
<p>Concerning the precedences of operators, # has the highest precedence, followed by *, + and ?, then concatenation, then | (alternation).</p>
<h2>Rule actions</h2>
<p>The actions are arbitrary F# expressions. Additionally, <code>lexbuf</code> is bound to the current lexer buffer.</p>
<p>Some typical uses for <code>lexbuf</code>, in conjunction with the operations on lexer buffers provided by the FSharp.Text.Lexing standard library module, are listed below.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">lexeme</span> <span class="i">lexbuf</span>
</code></pre></td>
</tr>
</table>
<p>Return the matched string.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">lexbuf</span><span class="o">.</span><span class="i">LexemeChar</span> <span class="i">n</span>
</code></pre></td>
</tr>
</table>
<p>Return the nth character in the matched string. The first character corresponds to n = 0.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">lexbuf</span><span class="o">.</span><span class="i">StartPos</span>
</code></pre></td>
</tr>
</table>
<p>Return the data on the absolute position in the input text of the beginning of the matched string (i.e. the offset of the first character of the matched string) in an object of type Position. The first character read from the input text has offset 0.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">lexbuf</span><span class="o">.</span><span class="i">EndPos</span>
</code></pre></td>
</tr>
</table>
<p>Return the data on absolute position in the input text of the end of the matched string (i.e. the offset of the first character after the matched string) in an object of type Position. The first character read from the input text has offset 0.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">entrypoint</span> [<span class="i">exp1</span>
</code></pre></td>
</tr>
</table>
<p>(Where entrypoint is the name of another entry point in the same lexer definition.) Recursively call the lexer on the given entry point. Notice that lexbuf is the last argument. Useful for lexing nested comments, for example.</p>
<h2>The Position type</h2>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
<span class="l">26: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">Position</span> <span class="o">=</span> 
{ <span class="c">/// The file name for the position</span>
  <span class="i">pos_fname</span><span class="o">:</span> <span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="i">string</span>
  <span class="c">/// The line number for the position</span>
  <span class="i">pos_lnum</span><span class="o">:</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="i">int</span>
  <span class="c">/// The absolute offset of the beginning of the line</span>
  <span class="i">pos_bol</span><span class="o">:</span> <span onmouseout="hideTip(event, 'fs4', 5)" onmouseover="showTip(event, 'fs4', 5)" class="i">int</span>
  <span class="c">/// The absolute offset of the column for the position</span>
  <span class="i">pos_cnum</span><span class="o">:</span> <span onmouseout="hideTip(event, 'fs4', 6)" onmouseover="showTip(event, 'fs4', 6)" class="i">int</span> }
 <span class="c">/// The file name associated with the input stream.</span>
 <span class="k">member</span> <span class="i">FileName</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs3', 7)" onmouseover="showTip(event, 'fs3', 7)" class="i">string</span>
 <span class="c">/// The line number in the input stream, assuming fresh positions have been updated </span>
 <span class="c">/// using AsNewLinePos() and by modifying the EndPos property of the LexBuffer.</span>
 <span class="k">member</span> <span class="i">Line</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs4', 8)" onmouseover="showTip(event, 'fs4', 8)" class="i">int</span>
 <span class="c">/// The character number in the input stream</span>
 <span class="k">member</span> <span class="i">AbsoluteOffset</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs4', 9)" onmouseover="showTip(event, 'fs4', 9)" class="i">int</span>
 <span class="c">/// Return absolute offset of the start of the line marked by the position</span>
 <span class="k">member</span> <span class="i">StartOfLineAbsoluteOffset</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs4', 10)" onmouseover="showTip(event, 'fs4', 10)" class="i">int</span>
 <span class="c">/// Return the column number marked by the position, i.e. the difference between the AbsoluteOffset and the StartOfLineAbsoluteOffset</span>
 <span class="k">member</span> <span class="i">Column</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs4', 11)" onmouseover="showTip(event, 'fs4', 11)" class="i">int</span>
 <span class="c">// Given a position just beyond the end of a line, return a position at the start of the next line</span>
 <span class="k">member</span> <span class="i">NextLine</span> <span class="o">:</span> <span class="i">Position</span>     
 <span class="c">/// Given a position at the start of a token of length n, return a position just beyond the end of the token</span>
 <span class="k">member</span> <span class="i">EndOfToken</span><span class="o">:</span> <span class="i">n</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs4', 12)" onmouseover="showTip(event, 'fs4', 12)" class="i">int</span> <span class="k">-&gt;</span> <span class="i">Position</span>
 <span class="c">/// Gives a position shifted by specified number of characters</span>
 <span class="k">member</span> <span class="i">ShiftColumnBy</span><span class="o">:</span> <span class="i">by</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs4', 13)" onmouseover="showTip(event, 'fs4', 13)" class="i">int</span> <span class="k">-&gt;</span> <span class="i">Position</span>
</code></pre></td>
</tr>
</table>
<h2>Sample input</h2>
<p>This is taken from the <code>Parsing</code> sample previously in the F# distribution. See below for information on <code>newline</code> and line counting.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">digit</span> <span class="o">=</span> [<span class="s">&#39;0&#39;</span><span class="o">-</span><span class="s">&#39;9&#39;</span>]
<span class="k">let</span> <span class="i">whitespace</span> <span class="o">=</span> [<span class="s">&#39; &#39;</span> <span class="s">&#39;\t&#39;</span> ]
<span class="k">let</span> <span class="i">newline</span> <span class="o">=</span> (<span class="s">&#39;\n&#39;</span> | <span class="s">&#39;\r&#39;</span> <span class="s">&#39;\n&#39;</span>)


<span class="i">rule</span> <span class="i">token</span> <span class="o">=</span> <span class="i">parse</span>
| <span class="i">whitespace</span>     { <span class="i">token</span> <span class="i">lexbuf</span> }
| <span class="i">newline</span>        { <span class="i">newline</span> <span class="i">lexbuf</span>; <span class="i">token</span> <span class="i">lexbuf</span> }
| <span class="s">&quot;while&quot;</span>        { <span class="i">WHILE</span> }
| <span class="s">&quot;begin&quot;</span>        { <span class="i">BEGIN</span> }
| <span class="s">&quot;end&quot;</span>          { <span class="i">END</span> }
| <span class="s">&quot;do&quot;</span>           { <span class="i">DO</span> }
| <span class="s">&quot;if&quot;</span>           { <span class="i">IF</span> }
| <span class="s">&quot;then&quot;</span>         { <span class="i">THEN</span> }
| <span class="s">&quot;else&quot;</span>         { <span class="i">ELSE</span> }
| <span class="s">&quot;print&quot;</span>        { <span class="i">PRINT</span> }
| <span class="s">&quot;decr&quot;</span>         { <span class="i">DECR</span> }
| <span class="s">&quot;(&quot;</span>            { <span class="i">LPAREN</span> }
| <span class="s">&quot;)&quot;</span>            { <span class="i">RPAREN</span> }
| <span class="s">&quot;;&quot;</span>            { <span class="i">SEMI</span> }
| <span class="s">&quot;:=&quot;</span>           { <span class="i">ASSIGN</span> }
| [<span class="s">&#39;a&#39;</span><span class="o">-</span><span class="s">&#39;z&#39;</span>]<span class="o">+</span>     { <span class="i">ID</span>(<span class="i">lexeme</span> <span class="i">lexbuf</span>) }
| [<span class="s">&#39;-&#39;</span>]<span class="o">?</span><span class="i">digit</span><span class="o">+</span>   { <span class="i">INT</span> (<span class="i">Int32</span><span class="o">.</span><span class="i">Parse</span>(<span class="i">lexeme</span> <span class="i">lexbuf</span>)) }
| [<span class="s">&#39;-&#39;</span>]<span class="o">?</span><span class="i">digit</span><span class="o">+</span>(<span class="s">&#39;.&#39;</span><span class="i">digit</span><span class="o">+</span>)<span class="o">?</span>([<span class="s">&#39;e&#39;&#39;E&#39;</span>]<span class="i">digit</span><span class="o">+</span>)<span class="o">?</span>   { <span class="i">FLOAT</span> (<span class="i">Double</span><span class="o">.</span><span class="i">Parse</span>(<span class="i">lexeme</span> <span class="i">lexbuf</span>)) }
| <span class="i">eof</span>            { <span class="i">EOF</span> }
</code></pre></td>
</tr>
</table>
<p>More than one lexer state is permitted - use</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">rule</span> <span class="i">state1</span> <span class="o">=</span>
 | <span class="s">&quot;this&quot;</span>    { <span class="i">state2</span> <span class="i">lexbuf</span> }
 | <span class="o">..</span><span class="o">.</span>
<span class="k">and</span> <span class="i">state2</span> <span class="o">=</span>
 | <span class="s">&quot;that&quot;</span>    { <span class="i">state1</span> <span class="i">lexbuf</span> }
 | <span class="o">..</span><span class="o">.</span>
</code></pre></td>
</tr>
</table>
<p>States can be passed arguments:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">rule</span> <span class="i">state1</span> <span class="i">arg1</span> <span class="i">arg2</span> <span class="o">=</span> <span class="o">..</span><span class="o">.</span>
 | <span class="s">&quot;this&quot;</span>    { <span class="i">state2</span> (<span class="i">arg1</span><span class="o">+</span><span class="n">1</span>) (<span class="i">arg2</span><span class="o">+</span><span class="n">2</span>) <span class="i">lexbuf</span> }
 | <span class="o">..</span><span class="o">.</span>
<span class="k">and</span> <span class="i">state2</span> <span class="i">arg1</span> <span class="i">arg2</span> <span class="o">=</span> <span class="o">..</span><span class="o">.</span>
 | <span class="o">..</span><span class="o">.</span>
</code></pre></td>
</tr>
</table>
<p><strong>Using a lexer</strong></p>
<p>If in the first example above the constructors <code>INT</code> etc generate values of type <code>tok</code> then the above generates a lexer with a function</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">val</span> <span class="i">token</span> <span class="o">:</span> <span class="i">LexBuffer</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs5', 14)" onmouseover="showTip(event, 'fs5', 14)" class="i">byte</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span class="i">tok</span>
</code></pre></td>
</tr>
</table>
<p>Once you have a lexbuffer you can call the above to generate new tokens. Typically you use some methods from <code>FSharp.Text.Lexing</code>
to create lex buffers, either a <code>LexBuffer&lt;byte&gt;</code> for ASCII lexing, or <code>LexBuffer&lt;char&gt;</code> for Unicode lexing.</p>
<p>Some ways of creating lex buffers are by using:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">LexBuffer</span><span class="o">&lt;</span>_<span class="o">&gt;</span><span class="o">.</span><span class="i">FromChars</span>  
<span class="i">LexBuffer</span><span class="o">&lt;</span>_<span class="o">&gt;</span><span class="o">.</span><span class="i">FromFunction</span>
<span class="i">LexBuffer</span><span class="o">&lt;</span>_<span class="o">&gt;</span><span class="o">.</span><span class="i">FromStream</span>
<span class="i">LexBuffer</span><span class="o">&lt;</span>_<span class="o">&gt;</span><span class="o">.</span><span class="i">FromTextReader</span>
<span class="i">LexBuffer</span><span class="o">&lt;</span>_<span class="o">&gt;</span><span class="o">.</span><span class="i">FromArray</span>
</code></pre></td>
</tr>
</table>
<p>Within lexing actions the variable <code>lexbuf</code> is in scope and you may use properties on the <code>LexBuffer</code> type such as:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">lexbuf</span><span class="o">.</span><span class="i">Lexeme</span>  <span class="c">// get the lexeme as an array of characters or bytes</span>
<span class="i">LexBuffer</span><span class="o">.</span><span class="i">LexemeString</span> <span class="i">lexbuf</span> <span class="c">// get the lexeme as a string, for Unicode lexing</span>
</code></pre></td>
</tr>
</table>
<p>Lexing positions give locations in source files (the relevant type is <code>FSharp.Text.Lexing.Position</code>).</p>
<p>Generated lexers are nearly always used in conjunction with parsers generated by <code>FsYacc</code> (also documented on this site). See the Parsed Language starter template.</p>
<p>Command line options</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">fslex</span> <span class="o">&lt;</span><span class="i">filename</span><span class="o">&gt;</span>
    <span class="o">-</span><span class="i">o</span> <span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs3', 15)" onmouseover="showTip(event, 'fs3', 15)" class="i">string</span><span class="o">&gt;</span> <span class="i">Name</span> <span class="i">the</span> <span class="i">output</span> <span class="i">file</span><span class="o">.</span>

    <span class="o">--</span><span class="k">module</span> <span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs3', 16)" onmouseover="showTip(event, 'fs3', 16)" class="i">string</span><span class="o">&gt;</span> <span class="i">Define</span> <span class="i">the</span> <span class="i">F#</span> <span class="k">module</span> <span class="i">name</span> <span class="k">to</span> <span class="i">host</span> <span class="i">the</span> <span class="i">generated</span> <span class="i">parser</span><span class="o">.</span>

    <span class="o">--</span><span class="k">internal</span><span class="o">:</span> <span class="i">Generate</span> <span class="i">an</span> <span class="k">internal</span> <span class="k">module</span>

    <span class="o">--</span><span class="i">codepage</span> <span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs4', 17)" onmouseover="showTip(event, 'fs4', 17)" class="i">int</span><span class="o">&gt;</span> <span class="i">Assume</span> <span class="i">input</span> <span class="i">lexer</span> <span class="i">specification</span> <span class="i">file</span> <span class="i">is</span> <span class="i">encoded</span> <span class="k">with</span> <span class="i">the</span> <span class="i">given</span> <span class="i">codepage</span><span class="o">.</span>

    <span class="o">--</span><span class="i">light</span><span class="o">:</span> (<span class="i">ignored</span>)

    <span class="o">--</span><span class="i">light</span><span class="o">-</span><span class="i">off</span><span class="o">:</span> <span class="i">Add</span> <span class="prep">#light &quot;off&quot;</span> <span class="k">to</span> <span class="i">the</span> <span class="i">top</span> <span class="k">of</span> <span class="i">the</span> <span class="i">generated</span> <span class="i">file</span>

    <span class="o">--</span><span class="i">lexlib</span> <span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs3', 18)" onmouseover="showTip(event, 'fs3', 18)" class="i">string</span><span class="o">&gt;</span> <span class="i">Specify</span> <span class="i">the</span> <span class="k">namespace</span> <span class="k">for</span> <span class="i">the</span> <span class="i">implementation</span> <span class="k">of</span> <span class="i">the</span> <span class="i">lexer</span> <span class="i">table</span> <span class="i">interperter</span> (<span class="k">default</span> <span onmouseout="hideTip(event, 'fs6', 19)" onmouseover="showTip(event, 'fs6', 19)" class="i">FSharp</span><span class="o">.</span><span class="i">Text</span><span class="o">.</span><span class="i">Lexing</span>)

    <span class="o">--</span><span class="i">unicode</span><span class="o">:</span> <span class="i">Produce</span> <span class="i">a</span> <span class="i">lexer</span> <span class="k">for</span> <span class="k">use</span> <span class="k">with</span> <span class="n">16</span><span class="o">-</span><span class="i">bit</span> <span class="i">unicode</span> <span class="i">characters</span><span class="o">.</span>

    <span class="o">--</span><span class="i">help</span><span class="o">:</span> <span class="i">display</span> <span class="i">this</span> <span onmouseout="hideTip(event, 'fs7', 20)" onmouseover="showTip(event, 'fs7', 20)" class="i">list</span> <span class="k">of</span> <span class="i">options</span>

    <span class="o">-</span><span class="i">help</span><span class="o">:</span> <span class="i">display</span> <span class="i">this</span> <span onmouseout="hideTip(event, 'fs7', 21)" onmouseover="showTip(event, 'fs7', 21)" class="i">list</span> <span class="k">of</span> <span class="i">options</span>
</code></pre></td>
</tr>
</table>
<p>Positions and line counting in lexers</p>
<p>Within a lexer lines can in theory be counted simply by incrementing a global variable or a passed line number count:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">rule</span> <span class="i">token</span> <span class="i">line</span> <span class="o">=</span> <span class="o">..</span><span class="o">.</span>
 | <span class="s">&quot;\n&quot;</span> | <span class="s">&#39;\r&#39;</span> <span class="s">&#39;\n&#39;</span>    { <span class="i">token</span> (<span class="i">line</span><span class="o">+</span><span class="n">1</span>) }
 | <span class="o">..</span><span class="o">.</span>
</code></pre></td>
</tr>
</table>
<p>However for character positions this is tedious, as it means every action becomes polluted with character counting, as you have to manually attach line numbers to tokens. Also, for error reporting writing service it is useful to have position information associated held as part of the state in the lexbuffer itself.</p>
<p>Thus F# follows the <code>OCamlLex</code> model where the lexer and parser state carry <code>position</code> values that record information for the current match (<code>lex</code>) and the <code>l.h.s</code>/<code>r.h.s</code> of the grammar productions (<code>yacc</code>).</p>
<p>The information carried for each position is:</p>
<ul>
<li>a filename</li>
<li>a current 'absolute' character number</li>
<li>a placeholder for a user-tracked beginning-of-line marker</li>
<li>a placeholder for a user-tracked line number count.</li>
</ul>
<h2>Passing state through lexers</h2>
<p>It is sometimes under-appreciated that you can pass arguments around between lexer states. For example, in one example we used imperative state to track a line number.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">current_line</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 22)" onmouseover="showTip(event, 'fs8', 22)" class="i">ref</span> <span class="n">0</span>
<span class="k">let</span> <span class="i">current_char</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 23)" onmouseover="showTip(event, 'fs8', 23)" class="i">ref</span> <span class="n">0</span>
<span class="k">let</span> <span class="i">set_next_line</span> <span class="i">lexbuf</span> <span class="o">=</span> <span class="o">..</span>

<span class="o">..</span><span class="o">.</span>
<span class="i">rule</span> <span class="i">main</span> <span class="o">=</span> <span class="i">parse</span>
  | <span class="o">..</span><span class="o">.</span>
  | <span class="s">&quot;//&quot;</span> [<span class="o">^</span> <span class="s">&#39;\n&#39;</span>]<span class="o">*</span> <span class="s">&#39;\n&#39;</span> {
       <span class="i">set_next_line</span> <span class="i">lexbuf</span>; <span class="i">main</span> <span class="i">lexbuf</span>
    }
</code></pre></td>
</tr>
</table>
<p>This sort of imperative code is better replaced by passing arguments:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">rule</span> <span class="i">main</span> <span class="i">line</span> <span onmouseout="hideTip(event, 'fs1', 24)" onmouseover="showTip(event, 'fs1', 24)" class="i">char</span> <span class="o">=</span> <span class="i">parse</span>
  | <span class="o">..</span><span class="o">.</span>
  | <span class="s">&quot;//&quot;</span> [<span class="o">^</span> <span class="s">&#39;\n&#39;</span>]<span class="o">*</span> <span class="s">&#39;\n&#39;</span> {
       <span class="i">main</span> (<span class="i">line</span><span class="o">+</span><span class="n">1</span>) <span class="n">0</span> <span class="i">lexbuf</span>
    }
</code></pre></td>
</tr>
</table>
<p>A good example is that when lexing a comment you want to pass through the start-of-comment position so that you can give a good error message if no end-of-comment is found. Or likewise you may want to pass through the number of nested of comments.</p>

<div class="tip" id="fs1">Multiple items<br />val char : value:&#39;T -&gt; char (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.char<br /><br />--------------------<br />type char = System.Char<br /><br />Full name: Microsoft.FSharp.Core.char</div>
<div class="tip" id="fs2">val set : elements:seq&lt;&#39;T&gt; -&gt; Set&lt;&#39;T&gt; (requires comparison)<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.set</div>
<div class="tip" id="fs3">Multiple items<br />val string : value:&#39;T -&gt; string<br /><br />Full name: Microsoft.FSharp.Core.Operators.string<br /><br />--------------------<br />type string = System.String<br /><br />Full name: Microsoft.FSharp.Core.string</div>
<div class="tip" id="fs4">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.int<br /><br />--------------------<br />type int = int32<br /><br />Full name: Microsoft.FSharp.Core.int<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; = int<br /><br />Full name: Microsoft.FSharp.Core.int&lt;_&gt;</div>
<div class="tip" id="fs5">Multiple items<br />val byte : value:&#39;T -&gt; byte (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.byte<br /><br />--------------------<br />type byte = System.Byte<br /><br />Full name: Microsoft.FSharp.Core.byte</div>
<div class="tip" id="fs6">namespace Microsoft.FSharp</div>
<div class="tip" id="fs7">type &#39;T list = List&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.list&lt;_&gt;</div>
<div class="tip" id="fs8">Multiple items<br />val ref : value:&#39;T -&gt; &#39;T ref<br /><br />Full name: Microsoft.FSharp.Core.Operators.ref<br /><br />--------------------<br />type &#39;T ref = Ref&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Core.ref&lt;_&gt;</div>

        </div>
        <div class="span3">
          <img src="/FsLexYacc/img/logo.png" alt="F# Project" style="width:150px;margin:10px" />
          <a href="https://travis-ci.org/fsprojects/FsLexYacc" style="margin-left: 20px;padding-right: 150px;">
            <img src="https://travis-ci.org/fsprojects/FsLexYacc.svg" alt="travis-ci" />
          </a>
          <a href="https://ci.appveyor.com/project/fsgit/fslexyacc" style="margin-left: 20px;">
            <img src="https://ci.appveyor.com/api/projects/status/061nqkynrysnyiv7" alt="appveyor-ci" />
          </a>
          <ul class="nav nav-list" id="menu" style="margin-top: 20px;">
            <li class="nav-header">FsLexYacc</li>
            <li><a href="/FsLexYacc/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="https://www.nuget.org/packages/FsLexYacc/">Get Library via NuGet</a></li>
            <li><a href="http://github.com/fsprojects/FsLexYacc">Source Code on GitHub</a></li>
            <li><a href="http://github.com/fsprojects/FsLexYacc/blob/master/LICENSE.txt">License</a></li>
            <li><a href="http://github.com/fsprojects/FsLexYacc/blob/master/RELEASE_NOTES.md">Release Notes</a></li>
            
            <li class="nav-header">Getting started</li>
            <li><a href="/FsLexYacc/fslex.html">Using FsLex</a></li>
            <li><a href="/FsLexYacc/fsyacc.html">Using FsYacc</a></li>

            <li class="nav-header">Documentation</li>
            <li><a href="/FsLexYacc/reference/index.html">API Reference</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="http://github.com/fsprojects/FsLexYacc"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
  </body>
  </html>
